Serial GC:
Сборщик работает всегда в один поток. 
Время сборки Young объектов представляет собой синусоиду. Не смог установить с чем это свазано и какова зависимость. 
Например:
[36.876s][info][gc] GC(59) Pause Young (Allocation Failure) 1682M->742M(3959M) 316.060ms
[37.317s][info][gc] GC(60) Pause Young (Allocation Failure) 1834M->763M(3959M) 184.842ms
[37.655s][info][gc] GC(61) Pause Young (Allocation Failure) 1855M->684M(3959M) 62.573ms

Когда память заканчивается запускается Full сборка, которая проходит в 4 основных этапа:
GC(28) Phase 1: Mark live objects
GC(28) Phase 2: Compute new object addresses
GC(28) Phase 3: Adjust pointers
GC(28) Phase 4: Move objects
Время полной сборки мусора является суммой времени затраченной на каждый этап. 

С увеличением выделяемого объема памяти, количество сборок сокращается.
При этом среднее время на сбор мусора Young объектов, остается, примерно, таким же.
При наступлении Major GC время на сборку сильно увеличивается. С объемом памяти и количеством
объектов, котрые нужно обработать. 


Parallel GC:

Данный сборщик выполняет работу в несколько потоков. Количество потоков может варьироваться.
В моих тестах количество потоков было от 2х до 4х
Full сборка отличается от Serial и состоит из следующих фаз:
GC(98) Marking Phase
GC(98) Summary Phase
GC(98) Adjust Roots
GC(98) Compaction Phase
GC(98) Post Compact
Общее время сборки так же явлеятеся суммой всех фаз.Compaction Phase, что позволяет помещать
большие объекты в eden более эффективно. 
В отличии от Serial GC данный сборщик производит оптимизацию места в памяти 
Parallel GC показал бОльщую эффективность:
при одинаковых входных данных(объем выделенной памяти, размер объектов в списке и т.д.),
общее количество сборок и сборок Major меньше при использовании Parallel GC.
С увеличением объема выделяемой памяти тенденция сохраняется, и разрыв в производительности
в пользу Parallel GC увеличивается.

G1:

Garbage-First осуществляет работу в несколько потоков до 4х, дополнительно у него есть concurrent потоки
Concurrent Cycle
Concurrent Clear Claimed Marks
Concurrent Scan Root Regions
Т.е. помимо сборки он использует concurrent поток для сбора предварительной информации (если я правильно понял). 
Сборка запускается чаще, но на более короткие промежутки веремени по сравнению с другими сборщиками. 
Full сборка осуществляется в 4 фазы
GC(30) Phase 1: Mark live objects
GC(30) Phase 1: Mark live objects
GC(30) Phase 2: Prepare for compaction
GC(30) Phase 3: Adjust pointers
GC(30) Phase 4: Compact heap
Как и в ParallelGC общее время является суммой времени на каждую фазу.

Conclusion:

На мой взгляд, в современных системах нет никакого практического смысла использовать Serial сборщик. Многопоточность
даёт существенный прирост производительности при сборе мусора.
Если сравнивать Parallel GC и G1, считаю, что G1 работает лучше.
Он имеет преимущество в работе приложений, которые чувствительны к задержкам. Более эффективно использует место в heap
Parallel GC дефрагментирует всю выделенную память целиком, в то время как G1 делает это для каждого региона и затрачивает
на данную процедуру меньше времени.
На лекции говорили, что Parallel GC хорош для преложений, которым важна пропускная способность.
В своих тестах, я увидел, что даже для больших объектов G1 показывает большую эффективность.
Например, при одних и тех же параметрах виртуальной машины и размере создаваемых объектов 
G1 тратит значительно меньше времени на Full сборку, и количество Full сборок меньще за одинаковый отрезок времени.
В случае с G1 полная сборка осуществлялась 2 раза за 2.8 секунды, с суммарно затраченным временем 431,25мс
Parallel GC запустил полную сборку дважды за 2.15 секунды и потратил на сбор мусора более двух секунд (2033,33мс). 

G1
[9.244s][info][gc] GC(30) Pause Full (G1 Evacuation Pause) 1024M->149M(1024M) 187.174ms
[12.110s][info][gc] GC(46) Pause Full (G1 Evacuation Pause) 1022M->186M(1024M) 244.075ms

Parallel GC
[7.251s][info][gc] GC(4) Pause Full (Ergonomics) 642M->239M(981M) 1275.611ms
[9.398s][info][gc] GC(9) Pause Full (Ergonomics) 620M->219M(910M) 757.721ms

Считаю, G1 оптимальным выбором для большинсва преложений.  